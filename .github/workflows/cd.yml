name: CD Pipeline

on:
  push:
    branches: [main]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

jobs:
  # Check project structure
  check-structure:
    name: Check Project Structure
    runs-on: ubuntu-latest
    outputs:
      backend-exists: ${{ steps.check.outputs.backend }}
      frontend-exists: ${{ steps.check.outputs.frontend }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîç Check directories
        id: check
        run: |
          if [ -d "backend" ]; then
            echo "backend=true" >> $GITHUB_OUTPUT
          else
            echo "backend=false" >> $GITHUB_OUTPUT
          fi
          if [ -d "frontend" ]; then
            echo "frontend=true" >> $GITHUB_OUTPUT
          else
            echo "frontend=false" >> $GITHUB_OUTPUT
          fi

  # Deployment decision
  deployment-decision:
    name: Deployment Decision
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.decide.outputs.environment }}
      should_deploy: ${{ steps.decide.outputs.should_deploy }}

    steps:
      - name: üéØ Decide deployment target
        id: decide
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  # Backend deployment
  deploy-backend:
    name: Deploy Backend
    needs: [deployment-decision, check-structure]
    if: needs.deployment-decision.outputs.should_deploy == 'true' && needs.check-structure.outputs.backend-exists == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.deployment-decision.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup Cloudflare Wrangler
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ env.CLOUDFLARE_API_TOKEN }}

      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: üì¶ Install dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: üöÄ Deploy to Cloudflare Workers
        id: deploy
        working-directory: ./backend
        env:
          # Áí∞Â¢ÉÂà•Secrets„ÇíÂãïÁöÑ„Å´ÈÅ∏Êäû
          CLERK_SECRET_KEY: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_CLERK_SECRET_KEY || secrets.STAGING_CLERK_SECRET_KEY }}
          OPENAI_API_KEY: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_OPENAI_API_KEY || secrets.STAGING_OPENAI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_ANTHROPIC_API_KEY || secrets.STAGING_ANTHROPIC_API_KEY }}
          LANGFUSE_PUBLIC_KEY: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_LANGFUSE_PUBLIC_KEY || secrets.STAGING_LANGFUSE_PUBLIC_KEY }}
          LANGFUSE_SECRET_KEY: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_LANGFUSE_SECRET_KEY || secrets.STAGING_LANGFUSE_SECRET_KEY }}
          REDIS_HOST: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_REDIS_HOST || secrets.STAGING_REDIS_HOST }}
          REDIS_PASSWORD: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_REDIS_PASSWORD || secrets.STAGING_REDIS_PASSWORD }}
        run: |
          if [[ "${{ needs.deployment-decision.outputs.environment }}" == "production" ]]; then
            wrangler deploy --env production
            echo "url=https://api.autoforgenexus.com" >> $GITHUB_OUTPUT
          else
            wrangler deploy --env staging
            echo "url=https://api-staging.autoforgenexus.com" >> $GITHUB_OUTPUT
          fi

      - name: üóÑÔ∏è Run database migrations
        working-directory: ./backend
        env:
          # Áí∞Â¢ÉÂà•Secrets„ÇíÂãïÁöÑ„Å´ÈÅ∏Êäû
          TURSO_DATABASE_URL: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_TURSO_DATABASE_URL || secrets.STAGING_TURSO_DATABASE_URL }}
          TURSO_AUTH_TOKEN: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_TURSO_AUTH_TOKEN || secrets.STAGING_TURSO_AUTH_TOKEN }}
        run: |
          alembic upgrade head

      - name: üß™ Smoke tests
        run: |
          curl -f ${{ steps.deploy.outputs.url }}/health || exit 1

  # Frontend deployment
  deploy-frontend:
    name: Deploy Frontend
    needs: [deployment-decision, check-structure]
    if: needs.deployment-decision.outputs.should_deploy == 'true' && needs.check-structure.outputs.frontend-exists == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.deployment-decision.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9

      - name: üü¢ Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
          cache-dependency-path: frontend/pnpm-lock.yaml

      - name: üì¶ Install dependencies
        working-directory: ./frontend
        run: pnpm install --frozen-lockfile

      - name: üîß Set environment variables
        working-directory: ./frontend
        env:
          # Áí∞Â¢ÉÂà•Secrets„ÇíÂãïÁöÑ„Å´ÈÅ∏Êäû
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_CLERK_PUBLIC_KEY || secrets.STAGING_CLERK_PUBLIC_KEY }}
          CLERK_SECRET_KEY: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_CLERK_SECRET_KEY || secrets.STAGING_CLERK_SECRET_KEY }}
          NEXT_PUBLIC_SENTRY_DSN: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_SENTRY_DSN || secrets.STAGING_SENTRY_DSN }}
          NEXT_PUBLIC_GA_MEASUREMENT_ID: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_GA_MEASUREMENT_ID || secrets.STAGING_GA_MEASUREMENT_ID }}
          NEXT_PUBLIC_POSTHOG_KEY: ${{ needs.deployment-decision.outputs.environment == 'production' && secrets.PROD_POSTHOG_KEY || secrets.STAGING_POSTHOG_KEY }}
        run: |
          if [[ "${{ needs.deployment-decision.outputs.environment }}" == "production" ]]; then
            echo "NEXT_PUBLIC_API_URL=https://api.autoforgenexus.com" >> .env.production
            echo "NEXT_PUBLIC_ENVIRONMENT=production" >> .env.production
          else
            echo "NEXT_PUBLIC_API_URL=https://api-staging.autoforgenexus.com" >> .env.staging
            echo "NEXT_PUBLIC_ENVIRONMENT=staging" >> .env.staging
          fi

      - name: üèóÔ∏è Build application
        working-directory: ./frontend
        run: |
          if [[ "${{ needs.deployment-decision.outputs.environment }}" == "production" ]]; then
            pnpm build:production
          else
            pnpm build:staging
          fi

      - name: üöÄ Deploy to Cloudflare Pages
        id: deploy
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ env.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: autoforgenexus-frontend
          directory: ./frontend/out
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ needs.deployment-decision.outputs.environment }}

      - name: üß™ Smoke tests
        run: |
          if [[ "${{ needs.deployment-decision.outputs.environment }}" == "production" ]]; then
            curl -f https://autoforgenexus.com || exit 1
            echo "url=https://autoforgenexus.com" >> $GITHUB_OUTPUT
          else
            curl -f https://staging.autoforgenexus.com || exit 1
            echo "url=https://staging.autoforgenexus.com" >> $GITHUB_OUTPUT
          fi

  # Post-deployment tasks
  post-deployment:
    name: Post Deployment
    needs: [deploy-backend, deploy-frontend]
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîî Send deployment notification
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -n "$DISCORD_WEBHOOK_URL" ]; then
            STATUS_COLOR=3066993  # Green for success
            STATUS_TEXT="‚úÖ Deployment Complete!"

            if [ "${{ job.status }}" != "success" ]; then
              STATUS_COLOR=15158332  # Red for failure
              STATUS_TEXT="‚ùå Deployment Failed!"
            fi

            curl -X POST "$DISCORD_WEBHOOK_URL" \
              -H 'Content-type: application/json' \
              -H 'User-Agent: AutoForgeNexus-Deploy/1.0' \
              --data "{
                \"content\": \"$STATUS_TEXT\",
                \"embeds\": [{
                  \"title\": \"Deployment Status\",
                  \"color\": $STATUS_COLOR,
                  \"fields\": [
                    { \"name\": \"Environment\", \"value\": \"${{ needs.deployment-decision.outputs.environment }}\", \"inline\": true },
                    { \"name\": \"Backend URL\", \"value\": \"${{ needs.deploy-backend.outputs.url }}\", \"inline\": false },
                    { \"name\": \"Frontend URL\", \"value\": \"${{ needs.deploy-frontend.outputs.url }}\", \"inline\": false }
                  ],
                  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
                }]
              }" \
              --max-time 30 \
              --fail-with-body || echo "‚ö†Ô∏è Failed to send Discord notification"
          fi
        if: always()

      - name: üìä Update deployment metrics
        run: |
          echo "Deployment completed at $(date)" >> deployment.log
          # Add custom metrics tracking here

  # Rollback mechanism
  rollback:
    name: Rollback Deployment
    needs: [deploy-backend, deploy-frontend]
    if: failure()
    runs-on: ubuntu-latest

    steps:
      - name: üîÑ Initiate rollback
        run: |
          echo "‚ö†Ô∏è Deployment failed, initiating rollback..."
          # Add rollback logic here

      - name: üîî Send rollback notification
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -n "$DISCORD_WEBHOOK_URL" ]; then
            curl -X POST "$DISCORD_WEBHOOK_URL" \
              -H 'Content-type: application/json' \
              -H 'User-Agent: AutoForgeNexus-Deploy/1.0' \
              --data '{
                "content": "üö® **Deployment Failed!**",
                "embeds": [{
                  "title": "Rollback Initiated",
                  "description": "The deployment has failed and rollback has been initiated.",
                  "color": 15158332,
                  "fields": [
                    { "name": "Environment", "value": "${{ needs.deployment-decision.outputs.environment }}", "inline": true },
                    { "name": "Action", "value": "Rollback", "inline": true }
                  ],
                  "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
                }]
              }' \
              --max-time 30 \
              --fail-with-body || echo "‚ö†Ô∏è Failed to send Discord notification"
          fi